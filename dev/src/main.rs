use anyhow::{Context as _, Result};
use clap::{Parser, Subcommand};
use opendal::layers::RetryLayer;
use opendal::services::S3;
use opendal::Operator;
use serde::Serialize;
use std::collections::HashMap;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command as ProcessCommand;
use std::process::Stdio;
use time::format_description::well_known::Rfc3339;

#[derive(Parser)]
#[command(name = "luban-dev", version, about = "Development helpers for Luban")]
struct Cli {
    #[command(subcommand)]
    cmd: Command,
}

#[derive(Subcommand)]
enum Command {
    /// Package release artifacts for the given target.
    Package {
        /// `darwin-aarch64`, `darwin-x86_64`, `darwin-universal`, `linux-x86_64`, `linux-aarch64`,
        /// `windows-x86_64`, or `windows-aarch64`.
        target: String,

        /// `release` or `debug`.
        #[arg(long, default_value = "release")]
        profile: String,

        /// Output directory for packaged artifacts.
        #[arg(long, default_value = "dist")]
        out_dir: PathBuf,
    },

    /// Upload packaged artifacts (and optionally `latest.json`) to Cloudflare R2.
    Upload {
        /// Path to the package environment file generated by `just package`.
        #[arg(long, default_value = "dist/package.env")]
        package_env: PathBuf,

        /// Upload `latest.json` (defaults to true).
        #[arg(long, default_value_t = true, action = clap::ArgAction::Set)]
        latest: bool,
    },

    /// Generate `latest.json` from one or more package environment files.
    Manifest {
        /// Path to a directory containing one or more `package.env` files.
        #[arg(long, default_value = "dist")]
        packages_dir: PathBuf,

        /// Output path for the generated manifest.
        #[arg(long, default_value = "dist/latest.json")]
        out: PathBuf,
    },

    /// Upload a pre-built `latest.json` to Cloudflare R2.
    UploadManifest {
        /// Path to the JSON manifest to upload as `latest.json`.
        #[arg(long, default_value = "dist/latest.json")]
        manifest: PathBuf,
    },
}

fn env_var(key: &str) -> Result<String> {
    std::env::var(key).with_context(|| format!("missing required env var: {key}"))
}

fn env_var_opt(key: &str) -> Option<String> {
    std::env::var(key).ok()
}

fn read_kv_file(path: &Path) -> Result<HashMap<String, String>> {
    let contents = std::fs::read_to_string(path).with_context(|| format!("read {}", path.display()))?;
    let mut out = HashMap::new();
    for (idx, line) in contents.lines().enumerate() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        let (k, v) = line
            .split_once('=')
            .with_context(|| format!("invalid key=value at {}:{}", path.display(), idx + 1))?;
        let key = k.trim().to_owned();
        let value = expand_kv_value(v.trim(), &out)
            .with_context(|| format!("expand value for {key} at {}:{}", path.display(), idx + 1))?;
        out.insert(key, value);
    }
    Ok(out)
}

fn expand_kv_value(raw: &str, kv: &HashMap<String, String>) -> Result<String> {
    let mut current = raw.to_owned();
    for _ in 0..16 {
        if !current.contains("${") {
            return Ok(current);
        }
        let expanded = expand_kv_value_once(&current, kv)?;
        if expanded == current {
            break;
        }
        current = expanded;
    }
    if current.contains("${") {
        anyhow::bail!("unresolved variable reference: {current}");
    }
    Ok(current)
}

fn expand_kv_value_once(raw: &str, kv: &HashMap<String, String>) -> Result<String> {
    let mut out = String::new();
    let mut i = 0;
    while let Some(pos) = raw[i..].find("${") {
        let abs = i + pos;
        out.push_str(&raw[i..abs]);
        let var_start = abs + 2;
        let Some(end_rel) = raw[var_start..].find('}') else {
            anyhow::bail!("missing closing '}}' for variable reference");
        };
        let var_end = var_start + end_rel;
        let var = raw[var_start..var_end].trim();
        if var.is_empty() {
            anyhow::bail!("empty variable name in reference");
        }

        let replacement = kv
            .get(var)
            .cloned()
            .or_else(|| std::env::var(var).ok())
            .with_context(|| format!("unknown variable: {var}"))?;

        out.push_str(&replacement);
        i = var_end + 1;
    }
    out.push_str(&raw[i..]);
    Ok(out)
}

fn file_name(path: &Path) -> Result<String> {
    path.file_name()
        .and_then(|s| s.to_str())
        .map(|s| s.to_owned())
        .with_context(|| format!("invalid file name: {}", path.display()))
}

fn run_cmd(mut cmd: ProcessCommand, context: &str) -> Result<()> {
    let status = cmd
        .stdin(Stdio::null())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .with_context(|| format!("spawn {context}"))?;
    if status.success() {
        return Ok(());
    }
    anyhow::bail!("{context} failed (exit {status})");
}

fn cmd_capture_stdout_if_ok(mut cmd: ProcessCommand) -> Option<String> {
    cmd.stdin(Stdio::null());
    let output = cmd.output().ok()?;
    if !output.status.success() {
        return None;
    }
    let stdout = String::from_utf8_lossy(&output.stdout).trim().to_owned();
    if stdout.is_empty() { None } else { Some(stdout) }
}

fn git_rev_parse_head() -> String {
    let mut cmd = ProcessCommand::new("git");
    cmd.args(["rev-parse", "HEAD"]);
    cmd_capture_stdout_if_ok(cmd).unwrap_or_else(|| "unknown".to_owned())
}

fn git_exact_tag() -> Option<String> {
    let mut cmd = ProcessCommand::new("git");
    cmd.args(["describe", "--tags", "--exact-match"]);
    cmd_capture_stdout_if_ok(cmd)
}

fn normalize_git_tag_version(tag: &str) -> Option<String> {
    let tag = tag.trim();
    if tag.is_empty() {
        return None;
    }
    Some(tag.strip_prefix('v').unwrap_or(tag).to_owned())
}

fn env_var_nonempty(key: &str) -> Option<String> {
    env_var_opt(key).and_then(|v| (!v.trim().is_empty()).then_some(v))
}

fn now_rfc3339_utc() -> Result<String> {
    let ts = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .context("system clock is before unix epoch")?
        .as_secs();
    let dt = time::OffsetDateTime::from_unix_timestamp(ts as i64).context("invalid timestamp")?;
    Ok(dt.format(&Rfc3339).context("format rfc3339")?)
}

fn find_first_app_dir(bundle_macos: &Path) -> Result<Option<PathBuf>> {
    if !bundle_macos.exists() {
        return Ok(None);
    }
    for entry in std::fs::read_dir(bundle_macos).with_context(|| format!("read_dir {}", bundle_macos.display()))? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() && path.extension().and_then(|s| s.to_str()) == Some("app") {
            return Ok(Some(path));
        }
    }
    Ok(None)
}

fn find_first_file_with_extension(dir: &Path, ext: &str) -> Result<Option<PathBuf>> {
    if !dir.exists() {
        return Ok(None);
    }

    let mut matches = Vec::new();
    for entry in std::fs::read_dir(dir).with_context(|| format!("read_dir {}", dir.display()))? {
        let entry = entry?;
        let path = entry.path();
        if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some(ext) {
            matches.push(path);
        }
    }
    matches.sort_by(|a, b| a.as_os_str().cmp(b.as_os_str()));
    Ok(matches.into_iter().next())
}

fn resolve_web_version() -> Result<String> {
    let raw = std::fs::read_to_string("web/package.json").context("read web/package.json")?;
    let value: serde_json::Value = serde_json::from_str(&raw).context("parse web/package.json")?;
    value
        .get("version")
        .and_then(|v| v.as_str())
        .map(|v| v.to_owned())
        .context("missing web package.json version")
}

fn build_web(
    profile: &str,
    build_channel: &str,
    git_hash: &str,
    git_tag: &str,
    build_time: &str,
    display_version: &str,
) -> Result<()> {
    let pnpm = if cfg!(windows) { "pnpm.cmd" } else { "pnpm" };

    if !ProcessCommand::new(pnpm).arg("--version").output().is_ok() {
        anyhow::bail!("pnpm not found; install pnpm to build the web UI");
    }

    let mut install = ProcessCommand::new(pnpm);
    install.current_dir("web").arg("install");
    run_cmd(install, "pnpm install")?;

    let build_script = if profile == "release" { "build" } else { "build" };
    let mut build = ProcessCommand::new(pnpm);
    build
        .current_dir("web")
        .arg(build_script)
        .env("NEXT_PUBLIC_LUBAN_VERSION", display_version)
        .env("NEXT_PUBLIC_LUBAN_BUILD_CHANNEL", build_channel)
        .env("NEXT_PUBLIC_LUBAN_COMMIT", git_hash)
        .env("NEXT_PUBLIC_LUBAN_GIT_TAG", git_tag)
        .env("NEXT_PUBLIC_LUBAN_BUILD_TIME", build_time);
    run_cmd(build, "pnpm build")?;

    std::fs::create_dir_all("web/out").context("create web/out")?;
    let mut f = std::fs::File::create("web/out/.gitkeep").context("create web/out/.gitkeep")?;
    f.write_all(b"\n").context("write web/out/.gitkeep")?;

    Ok(())
}

fn sign_archive(archive_path: &Path) -> Result<String> {
    let mut help = ProcessCommand::new("cargo");
    help.arg("tauri").arg("--help");
    run_cmd(help, "cargo tauri --help")?;

    // `cargo tauri signer sign` writes a `.sig` file next to the input file.
    // Use the file as the source of truth instead of parsing stdout.
    let mut sign = ProcessCommand::new("cargo");
    sign.arg("tauri").arg("signer").arg("sign").arg(archive_path);
    run_cmd(sign, "cargo tauri signer sign")?;

    let mut extension = archive_path
        .extension()
        .context("archive has no extension")?
        .to_os_string();
    extension.push(".sig");
    let sig_path = archive_path.with_extension(extension);

    let signature = std::fs::read_to_string(&sig_path)
        .with_context(|| format!("read signature {}", sig_path.display()))?
        .trim()
        .to_owned();
    if signature.is_empty() {
        anyhow::bail!("signature file is empty: {}", sig_path.display());
    }
    Ok(signature)
}

fn package_env_required() -> Result<()> {
    let has_key = std::env::var("TAURI_PRIVATE_KEY").is_ok()
        || std::env::var("TAURI_PRIVATE_KEY_PATH").is_ok()
        || std::env::var("TAURI_SIGNING_PRIVATE_KEY").is_ok();
    if !has_key {
        anyhow::bail!(
            "missing signing key; set TAURI_PRIVATE_KEY/TAURI_PRIVATE_KEY_PATH or TAURI_SIGNING_PRIVATE_KEY"
        );
    }
    Ok(())
}

fn apply_updater_signing_env(cmd: &mut ProcessCommand) {
    if env_var_opt("TAURI_SIGNING_PRIVATE_KEY").is_none() {
        if let Some(value) = env_var_opt("TAURI_PRIVATE_KEY") {
            cmd.env("TAURI_SIGNING_PRIVATE_KEY", value);
        } else if let Some(value) = env_var_opt("TAURI_PRIVATE_KEY_PATH") {
            cmd.env("TAURI_SIGNING_PRIVATE_KEY", value);
        }
    }

    if env_var_opt("TAURI_SIGNING_PRIVATE_KEY_PASSWORD").is_none() {
        if let Some(value) = env_var_opt("TAURI_PRIVATE_KEY_PASSWORD") {
            cmd.env("TAURI_SIGNING_PRIVATE_KEY_PASSWORD", value);
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct ArchiveSpec {
    program: &'static str,
    args: Vec<String>,
}

fn build_archive_spec(app_dir: &Path, archive_path: &Path, use_bsdtar: bool) -> Result<ArchiveSpec> {
    let app_parent = app_dir.parent().context("missing app parent dir")?;
    let app_name = app_dir.file_name().context("missing app dir name")?;

    if use_bsdtar {
        // The Tauri updater extracts archives via Rust's `tar` crate.
        // Some macOS metadata (xattrs/ACLs/flags) can cause extraction to fail
        // with `EPERM` on certain systems. Avoid embedding that metadata in
        // updater artifacts for better compatibility.
        let args = vec![
            "-C".to_owned(),
            app_parent.display().to_string(),
            "--no-xattrs".to_owned(),
            "--no-acls".to_owned(),
            "--no-fflags".to_owned(),
            "--no-mac-metadata".to_owned(),
            "-czf".to_owned(),
            archive_path.display().to_string(),
            app_name.to_string_lossy().to_string(),
        ];
        return Ok(ArchiveSpec { program: "bsdtar", args });
    }

    let args = vec![
        "-C".to_owned(),
        app_parent.display().to_string(),
        "-czf".to_owned(),
        archive_path.display().to_string(),
        app_name.to_string_lossy().to_string(),
    ];
    Ok(ArchiveSpec { program: "tar", args })
}

fn bsdtar_available() -> bool {
    ProcessCommand::new("bsdtar")
        .arg("--version")
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .is_ok()
}

fn build_tauri_build_command(
    target_triple: &str,
    build_flags: &[&str],
    build_channel: &str,
    git_hash: &str,
    git_tag: &str,
    build_time: &str,
    app_version: &str,
    bundles: Option<&str>,
    skip_stapling: bool,
) -> ProcessCommand {
    let config_patch = serde_json::json!({
        "version": app_version,
    })
    .to_string();

    let mut cmd = ProcessCommand::new("cargo");
    cmd.current_dir("crates/luban_tauri")
        .arg("tauri")
        .arg("build")
        .arg("--ci")
        .arg("--config")
        .arg(config_patch)
        .args(skip_stapling.then_some("--skip-stapling"))
        .args(
            bundles
                .into_iter()
                .flat_map(|value| ["--bundles", value].into_iter()),
        )
        .args(build_flags)
        .arg("--target")
        .arg(target_triple)
        // Always avoid Finder-driven DMG "aesthetics" because it can pop UI windows (osascript/Finder).
        // Tauri bundler enables `--skip-jenkins` when `CI=true`, which skips the AppleScript step.
        .env("CI", "true")
        .env("LUBAN_BUILD_CHANNEL", build_channel)
        .env("LUBAN_GIT_HASH", git_hash)
        .env("LUBAN_GIT_TAG", git_tag)
        .env("LUBAN_DISPLAY_VERSION", app_version)
        .env("LUBAN_BUILD_TIME", build_time);
    cmd
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum PackagePlatform {
    Macos,
    Linux,
    Windows,
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct PackageTargetSpec {
    platform: PackagePlatform,
    target_triple: &'static str,
    platform_key: &'static str,
    manifest_keys: &'static [&'static str],
}

fn resolve_package_target(target: &str) -> Result<PackageTargetSpec> {
    match target {
        "darwin-aarch64" => Ok(PackageTargetSpec {
            platform: PackagePlatform::Macos,
            target_triple: "aarch64-apple-darwin",
            platform_key: "darwin-aarch64",
            manifest_keys: &["darwin-aarch64"],
        }),
        "darwin-x86_64" => Ok(PackageTargetSpec {
            platform: PackagePlatform::Macos,
            target_triple: "x86_64-apple-darwin",
            platform_key: "darwin-x86_64",
            manifest_keys: &["darwin-x86_64"],
        }),
        "darwin-universal" => Ok(PackageTargetSpec {
            platform: PackagePlatform::Macos,
            target_triple: "universal-apple-darwin",
            platform_key: "darwin-universal",
            manifest_keys: &["darwin-aarch64", "darwin-x86_64"],
        }),
        "linux-x86_64" => Ok(PackageTargetSpec {
            platform: PackagePlatform::Linux,
            target_triple: "x86_64-unknown-linux-gnu",
            platform_key: "linux-x86_64",
            manifest_keys: &["linux-x86_64"],
        }),
        "linux-aarch64" => Ok(PackageTargetSpec {
            platform: PackagePlatform::Linux,
            target_triple: "aarch64-unknown-linux-gnu",
            platform_key: "linux-aarch64",
            manifest_keys: &["linux-aarch64"],
        }),
        "windows-x86_64" => Ok(PackageTargetSpec {
            platform: PackagePlatform::Windows,
            target_triple: "x86_64-pc-windows-msvc",
            platform_key: "windows-x86_64",
            manifest_keys: &["windows-x86_64"],
        }),
        "windows-aarch64" => Ok(PackageTargetSpec {
            platform: PackagePlatform::Windows,
            target_triple: "aarch64-pc-windows-msvc",
            platform_key: "windows-aarch64",
            manifest_keys: &["windows-aarch64"],
        }),
        other => anyhow::bail!(
            "unsupported target: {}; supported targets: darwin-aarch64, darwin-x86_64, darwin-universal, linux-x86_64, linux-aarch64, windows-x86_64, windows-aarch64",
            other
        ),
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct PackagedPaths {
    version: String,
    platform_key: String,
    manifest_keys: Vec<String>,
    archive_name: String,
    archive_path: PathBuf,
    signature_path: PathBuf,
    signature: String,
    url: String,
    installer_name: Option<String>,
    installer_path: Option<PathBuf>,
}

fn find_first_file_in_dir(dir: &Path, ext: &str) -> Result<PathBuf> {
    find_first_file_with_extension(dir, ext)?
        .with_context(|| format!("{} bundle not found under: {}", ext, dir.display()))
}

fn run_package(target: String, profile: String, out_dir: PathBuf) -> Result<()> {
    package_env_required()?;

    let spec = resolve_package_target(&target)?;
    let target_triple = spec.target_triple;
    let platform_key = spec.platform_key;

    let (build_dir, build_flags) = match profile.as_str() {
        "release" => ("release", Vec::<&str>::new()),
        "debug" | "dev" => ("debug", vec!["--debug"]),
        other => anyhow::bail!("unsupported profile: {}; supported: release, debug", other),
    };

    let build_channel = if profile == "release" { "release" } else { "dev" };
    let git_hash = git_rev_parse_head();
    let git_tag = if build_channel == "release" {
        git_exact_tag().unwrap_or_default()
    } else {
        String::new()
    };
    let build_time = now_rfc3339_utc()?;

    let display_version = if let Some(v) = env_var_nonempty("LUBAN_DISPLAY_VERSION") {
        v
    } else if let Some(v) = normalize_git_tag_version(&git_tag) {
        v
    } else {
        resolve_web_version()?
    };

    build_web(
        &profile,
        build_channel,
        &git_hash,
        &git_tag,
        &build_time,
        &display_version,
    )?;

    let (bundles, skip_stapling) = match spec.platform {
        PackagePlatform::Macos => (Some("app,dmg"), false),
        PackagePlatform::Linux => (Some("appimage"), false),
        PackagePlatform::Windows => (Some("msi"), false),
    };

    let mut tauri_build = build_tauri_build_command(
        target_triple,
        &build_flags,
        build_channel,
        &git_hash,
        &git_tag,
        &build_time,
        &display_version,
        bundles,
        skip_stapling,
    );
    apply_updater_signing_env(&mut tauri_build);
    run_cmd(tauri_build, "cargo tauri build")?;

    let version = display_version;
    std::fs::create_dir_all(&out_dir).with_context(|| format!("create {}", out_dir.display()))?;

    let base_url = env_var_opt("LUBAN_RELEASE_BASE_URL").unwrap_or_else(|| "https://releases.luban.dev".to_owned());
    let packaged = match spec.platform {
        PackagePlatform::Macos => {
            let bundle_macos = PathBuf::from(format!("target/{target_triple}/{build_dir}/bundle/macos"));
            let bundle_dmg = PathBuf::from(format!("target/{target_triple}/{build_dir}/bundle/dmg"));

            let app_dir = find_first_app_dir(&bundle_macos)?
                .with_context(|| format!("macOS bundle not found under: {}", bundle_macos.display()))?;

            let dmg_path = find_first_file_in_dir(&bundle_dmg, "dmg")?;
            let installer_name = format!("Luban_{version}_{platform_key}.dmg");
            let installer_path = out_dir.join(&installer_name);
            std::fs::copy(&dmg_path, &installer_path)
                .with_context(|| format!("copy {} to {}", dmg_path.display(), installer_path.display()))?;

            let archive_name = format!("Luban_{version}_{platform_key}.app.tar.gz");
            let archive_path = out_dir.join(&archive_name);

            let archive_spec = build_archive_spec(&app_dir, &archive_path, bsdtar_available())?;
            let mut archive = ProcessCommand::new(archive_spec.program);
            archive.args(archive_spec.args);
            run_cmd(archive, "archive app")?;

            let signature = sign_archive(&archive_path)?;

            let mut sig_ext = archive_path
                .extension()
                .context("archive has no extension")?
                .to_os_string();
            sig_ext.push(".sig");
            let signature_path = archive_path.with_extension(sig_ext);

            let url = format!("{}/{}/{}", base_url.trim_end_matches('/'), version, archive_name);

            PackagedPaths {
                version: version.clone(),
                platform_key: platform_key.to_owned(),
                manifest_keys: spec.manifest_keys.iter().map(|s| (*s).to_owned()).collect(),
                archive_name,
                archive_path,
                signature_path,
                signature,
                url,
                installer_name: Some(installer_name),
                installer_path: Some(installer_path),
            }
        }
        PackagePlatform::Linux => {
            let bundle_appimage = PathBuf::from(format!("target/{target_triple}/{build_dir}/bundle/appimage"));
            let appimage_path = find_first_file_in_dir(&bundle_appimage, "AppImage")?;

            let archive_name = format!("Luban_{version}_{platform_key}.AppImage");
            let archive_path = out_dir.join(&archive_name);
            std::fs::copy(&appimage_path, &archive_path)
                .with_context(|| format!("copy {} to {}", appimage_path.display(), archive_path.display()))?;

            let signature = sign_archive(&archive_path)?;
            let mut sig_ext = archive_path
                .extension()
                .context("archive has no extension")?
                .to_os_string();
            sig_ext.push(".sig");
            let signature_path = archive_path.with_extension(sig_ext);

            let url = format!("{}/{}/{}", base_url.trim_end_matches('/'), version, archive_name);
            PackagedPaths {
                version: version.clone(),
                platform_key: platform_key.to_owned(),
                manifest_keys: spec.manifest_keys.iter().map(|s| (*s).to_owned()).collect(),
                archive_name,
                archive_path: archive_path.clone(),
                signature_path,
                signature,
                url,
                installer_name: None,
                installer_path: Some(archive_path),
            }
        }
        PackagePlatform::Windows => {
            let bundle_msi = PathBuf::from(format!("target/{target_triple}/{build_dir}/bundle/msi"));
            let msi_path = find_first_file_in_dir(&bundle_msi, "msi")?;

            let archive_name = format!("Luban_{version}_{platform_key}.msi");
            let archive_path = out_dir.join(&archive_name);
            std::fs::copy(&msi_path, &archive_path)
                .with_context(|| format!("copy {} to {}", msi_path.display(), archive_path.display()))?;

            let signature = sign_archive(&archive_path)?;
            let mut sig_ext = archive_path
                .extension()
                .context("archive has no extension")?
                .to_os_string();
            sig_ext.push(".sig");
            let signature_path = archive_path.with_extension(sig_ext);

            let url = format!("{}/{}/{}", base_url.trim_end_matches('/'), version, archive_name);
            PackagedPaths {
                version: version.clone(),
                platform_key: platform_key.to_owned(),
                manifest_keys: spec.manifest_keys.iter().map(|s| (*s).to_owned()).collect(),
                archive_name,
                archive_path: archive_path.clone(),
                signature_path,
                signature,
                url,
                installer_name: None,
                installer_path: Some(archive_path),
            }
        }
    };

    let env_path = out_dir.join("package.env");
    let env_contents = format!(
        "LUBAN_PACKAGE_VERSION={}\nLUBAN_PACKAGE_PLATFORM_KEY={}\nLUBAN_PACKAGE_MANIFEST_KEYS={}\nLUBAN_PACKAGE_ARCHIVE={}\nLUBAN_PACKAGE_URL={}\nLUBAN_PACKAGE_SIGNATURE={}\nLUBAN_PACKAGE_SIGNATURE_PATH={}\nLUBAN_PACKAGE_INSTALLER={}\n",
        packaged.version,
        packaged.platform_key,
        packaged.manifest_keys.join(","),
        packaged.archive_path.display(),
        packaged.url,
        packaged.signature,
        packaged.signature_path.display(),
        packaged
            .installer_path
            .as_ref()
            .map(|p| p.display().to_string())
            .unwrap_or_default(),
    );
    std::fs::write(&env_path, env_contents).with_context(|| format!("write {}", env_path.display()))?;

    if let Some(path) = &packaged.installer_path {
        println!("installer: {}", path.display());
    }
    println!("packaged: {}", packaged.archive_path.display());
    println!("package env: {}", env_path.display());
    println!("next: just upload");

    Ok(())
}

#[derive(Serialize)]
struct Manifest {
    version: String,
    notes: String,
    pub_date: String,
    platforms: HashMap<String, ManifestPlatform>,
}

#[derive(Serialize)]
struct ManifestPlatform {
    url: String,
    signature: String,
}

fn build_r2_operator(
    endpoint_url: &str,
    bucket: &str,
    region: &str,
    access_key_id: &str,
    secret_access_key: &str,
    session_token: Option<&str>,
) -> Result<Operator> {
    let mut builder = S3::default()
        .endpoint(endpoint_url)
        .bucket(bucket)
        .region(region)
        .access_key_id(access_key_id)
        .secret_access_key(secret_access_key);

    if let Some(token) = session_token {
        if !token.trim().is_empty() {
            builder = builder.session_token(token);
        }
    }

    // Avoid metadata calls that don't apply to local packaging workflows.
    let builder = builder.disable_ec2_metadata().disable_stat_with_override();

    Ok(Operator::new(builder)
        .context("build opendal S3 operator")?
        .layer(RetryLayer::new())
        .finish())
}

async fn upload_file(
    op: &Operator,
    bucket: &str,
    key: &str,
    path: &Path,
    content_type: &str,
    cache_control: &str,
) -> Result<()> {
    let body = tokio::fs::read(path)
        .await
        .with_context(|| format!("read upload body {}", path.display()))?;
    op.write_with(key, body)
        .content_type(content_type)
        .cache_control(cache_control)
        .await
        .with_context(|| format!("upload s3://{bucket}/{key}"))?;
    Ok(())
}

async fn run_upload(package_env: PathBuf) -> Result<()> {
    let r2_endpoint_url = env_var("R2_ENDPOINT_URL")?;
    let r2_bucket = env_var("R2_BUCKET")?;
    let access_key = env_var("AWS_ACCESS_KEY_ID")?;
    let secret_key = env_var("AWS_SECRET_ACCESS_KEY")?;
    let session_token = env_var_opt("AWS_SESSION_TOKEN");
    let region = env_var_opt("AWS_DEFAULT_REGION").unwrap_or_else(|| "auto".to_owned());

    let kv = read_kv_file(&package_env)?;
    let version = kv
        .get("LUBAN_PACKAGE_VERSION")
        .context("LUBAN_PACKAGE_VERSION missing from package.env")?
        .trim()
        .to_owned();
    let platform_key = kv
        .get("LUBAN_PACKAGE_PLATFORM_KEY")
        .context("LUBAN_PACKAGE_PLATFORM_KEY missing from package.env")?
        .trim()
        .to_owned();
    let installer_name = kv
        .get("LUBAN_PACKAGE_INSTALLER")
        .map(|p| p.trim())
        .filter(|p| !p.is_empty())
        .and_then(|p| Path::new(p).file_name().and_then(|s| s.to_str()).map(|s| s.to_owned()));
    let archive_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_ARCHIVE")
            .context("LUBAN_PACKAGE_ARCHIVE missing from package.env")?,
    );
    let signature_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_SIGNATURE_PATH")
            .context("LUBAN_PACKAGE_SIGNATURE_PATH missing from package.env")?,
    );
    let installer_path = kv
        .get("LUBAN_PACKAGE_INSTALLER")
        .map(|p| p.trim())
        .filter(|p| !p.is_empty())
        .map(PathBuf::from);

    let archive_name = file_name(&archive_path)?;
    let archive_key = format!("{version}/{archive_name}");
    let signature_key = format!("{archive_key}.sig");

    let op = build_r2_operator(
        &r2_endpoint_url,
        &r2_bucket,
        &region,
        &access_key,
        &secret_key,
        session_token.as_deref(),
    )?;

    upload_file(
        &op,
        &r2_bucket,
        &archive_key,
        &archive_path,
        content_type_for_path(&archive_path),
        "public, max-age=31536000, immutable",
    )
    .await?;

    upload_file(
        &op,
        &r2_bucket,
        &signature_key,
        &signature_path,
        "text/plain; charset=utf-8",
        "public, max-age=31536000, immutable",
    )
    .await?;

    if let Some(installer_path) = installer_path {
        let installer_name = file_name(&installer_path)?;
        if installer_path != archive_path {
            let installer_key = format!("{version}/{installer_name}");
            upload_file(
                &op,
                &r2_bucket,
                &installer_key,
                &installer_path,
                content_type_for_path(&installer_path),
                "public, max-age=31536000, immutable",
            )
            .await?;
        }

        let ext = installer_path
            .extension()
            .and_then(|s| s.to_str())
            .unwrap_or("bin");
        let installer_latest_key = format!("Luban_latest_{platform_key}.{ext}");
        upload_file(
            &op,
            &r2_bucket,
            &installer_latest_key,
            &installer_path,
            content_type_for_path(&installer_path),
            "no-cache",
        )
        .await?;
    }

    let base = env_var_opt("LUBAN_RELEASE_BASE_URL").unwrap_or_else(|| "https://releases.luban.dev".to_owned());
    if let Some(name) = installer_name {
        println!(
            "uploaded: {}/{}/{}",
            base.trim_end_matches('/'),
            version,
            name
        );
    }
    println!("uploaded: {}/{}", base.trim_end_matches('/'), archive_key);

    Ok(())
}

fn content_type_for_path(path: &Path) -> &'static str {
    match path.extension().and_then(|s| s.to_str()).unwrap_or("") {
        "gz" => "application/gzip",
        "json" => "application/json; charset=utf-8",
        "dmg" => "application/x-apple-diskimage",
        "msi" => "application/x-msi",
        "AppImage" => "application/octet-stream",
        "exe" => "application/vnd.microsoft.portable-executable",
        _ => "application/octet-stream",
    }
}

fn read_packages_envs(packages_dir: &Path) -> Result<Vec<PathBuf>> {
    let mut out = Vec::new();
    if !packages_dir.exists() {
        anyhow::bail!("packages dir does not exist: {}", packages_dir.display());
    }
    for entry in std::fs::read_dir(packages_dir).with_context(|| format!("read_dir {}", packages_dir.display()))? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            let env = path.join("package.env");
            if env.is_file() {
                out.push(env);
            }
            continue;
        }
        if path.is_file() && path.file_name().and_then(|s| s.to_str()) == Some("package.env") {
            out.push(path);
        }
    }
    out.sort();
    if out.is_empty() {
        anyhow::bail!(
            "no package.env files found under: {}; expected <dir>/package.env entries",
            packages_dir.display()
        );
    }
    Ok(out)
}

fn run_manifest(packages_dir: PathBuf, out: PathBuf) -> Result<()> {
    let env_paths = read_packages_envs(&packages_dir)?;
    let mut platforms = HashMap::<String, ManifestPlatform>::new();
    let mut version: Option<String> = None;

    for env_path in env_paths {
        let kv = read_kv_file(&env_path)?;
        let v = kv
            .get("LUBAN_PACKAGE_VERSION")
            .context("LUBAN_PACKAGE_VERSION missing")?
            .trim()
            .to_owned();
        if let Some(existing) = &version {
            if existing != &v {
                anyhow::bail!(
                    "version mismatch between packages: expected {}, got {} from {}",
                    existing,
                    v,
                    env_path.display()
                );
            }
        } else {
            version = Some(v);
        }

        let url = kv
            .get("LUBAN_PACKAGE_URL")
            .context("LUBAN_PACKAGE_URL missing")?
            .trim()
            .to_owned();
        let signature = kv
            .get("LUBAN_PACKAGE_SIGNATURE")
            .context("LUBAN_PACKAGE_SIGNATURE missing")?
            .trim()
            .to_owned();
        let keys = kv
            .get("LUBAN_PACKAGE_MANIFEST_KEYS")
            .context("LUBAN_PACKAGE_MANIFEST_KEYS missing")?
            .split(',')
            .map(|s| s.trim())
            .filter(|s| !s.is_empty())
            .map(|s| s.to_owned())
            .collect::<Vec<_>>();
        if keys.is_empty() {
            anyhow::bail!("empty manifest keys in {}", env_path.display());
        }

        for key in keys {
            platforms.insert(
                key,
                ManifestPlatform {
                    url: url.clone(),
                    signature: signature.clone(),
                },
            );
        }
    }

    let version = version.context("missing version while building manifest")?;
    let pub_date = now_rfc3339_utc()?;
    let manifest = Manifest {
        version,
        notes: "".to_owned(),
        pub_date,
        platforms,
    };

    if let Some(parent) = out.parent() {
        std::fs::create_dir_all(parent).with_context(|| format!("create {}", parent.display()))?;
    }
    std::fs::write(&out, serde_json::to_string_pretty(&manifest)?.to_owned() + "\n")
        .with_context(|| format!("write {}", out.display()))?;
    println!("manifest: {}", out.display());
    Ok(())
}

async fn run_upload_manifest(manifest: PathBuf) -> Result<()> {
    let r2_endpoint_url = env_var("R2_ENDPOINT_URL")?;
    let r2_bucket = env_var("R2_BUCKET")?;
    let access_key = env_var("AWS_ACCESS_KEY_ID")?;
    let secret_key = env_var("AWS_SECRET_ACCESS_KEY")?;
    let session_token = env_var_opt("AWS_SESSION_TOKEN");
    let region = env_var_opt("AWS_DEFAULT_REGION").unwrap_or_else(|| "auto".to_owned());

    let op = build_r2_operator(
        &r2_endpoint_url,
        &r2_bucket,
        &region,
        &access_key,
        &secret_key,
        session_token.as_deref(),
    )?;

    upload_file(
        &op,
        &r2_bucket,
        "latest.json",
        &manifest,
        "application/json; charset=utf-8",
        "no-cache",
    )
    .await?;

    let base = env_var_opt("LUBAN_RELEASE_BASE_URL").unwrap_or_else(|| "https://releases.luban.dev".to_owned());
    println!("uploaded: {}/latest.json", base.trim_end_matches('/'));
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();
    match cli.cmd {
        Command::Package { target, profile, out_dir } => run_package(target, profile, out_dir),
        Command::Upload { package_env, latest } => {
            run_upload(package_env.clone()).await?;
            if latest {
                // Preserve existing single-platform workflow: `just package && just upload` publishes `latest.json`.
                let packages_dir = package_env.parent().unwrap_or(Path::new(".")).to_path_buf();
                let manifest_path = packages_dir.join("latest.json");
                run_manifest(packages_dir, manifest_path.clone())?;
                run_upload_manifest(manifest_path).await?;
            }
            Ok(())
        }
        Command::Manifest { packages_dir, out } => run_manifest(packages_dir, out),
        Command::UploadManifest { manifest } => run_upload_manifest(manifest).await,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::ffi::OsStr;

    #[test]
    fn expand_kv_value_uses_prior_kv_entries() {
        let kv = HashMap::from([("FOO".to_owned(), "bar".to_owned())]);
        let expanded = expand_kv_value("prefix-${FOO}-suffix", &kv).expect("must expand");
        assert_eq!(expanded, "prefix-bar-suffix");
    }

    #[test]
    fn expand_kv_value_uses_process_env() {
        let kv = HashMap::new();
        let prev = std::env::var_os("LUBAN_TEST_ENV");
        unsafe {
            std::env::set_var("LUBAN_TEST_ENV", "value");
        }
        let expanded = expand_kv_value("${LUBAN_TEST_ENV}", &kv).expect("must expand");
        assert_eq!(expanded, "value");
        if let Some(v) = prev {
            unsafe {
                std::env::set_var("LUBAN_TEST_ENV", v);
            }
        } else {
            unsafe {
                std::env::remove_var("LUBAN_TEST_ENV");
            }
        }
    }

    #[test]
    fn expand_kv_value_errors_on_unknown_variable() {
        let kv = HashMap::new();
        let err = expand_kv_value("${LUBAN_TEST_ENV_MISSING}", &kv)
            .expect_err("must error on missing variable");
        assert!(format!("{err:#}").contains("unknown variable"));
    }

    #[test]
    fn build_archive_spec_uses_bsdtar_flags() {
        let app_dir = Path::new("/tmp/Luban.app");
        let archive_path = Path::new("/tmp/Luban_0.1.6_darwin-aarch64.app.tar.gz");
        let spec = build_archive_spec(app_dir, archive_path, true).expect("must build spec");
        assert_eq!(spec.program, "bsdtar");
        assert!(spec.args.iter().any(|arg| arg == "--no-xattrs"));
        assert!(spec.args.iter().any(|arg| arg == "--no-acls"));
        assert!(spec.args.iter().any(|arg| arg == "--no-fflags"));
        assert!(spec.args.iter().any(|arg| arg == "--no-mac-metadata"));
    }

    #[test]
    fn find_first_file_with_extension_returns_sorted_match() {
        let unique = format!(
            "luban-dev-test-{}-{}",
            std::process::id(),
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .expect("must get time")
                .as_nanos()
        );
        let root = std::env::temp_dir().join(unique);
        std::fs::create_dir_all(&root).expect("must create root dir");

        let a = root.join("a.dmg");
        let b = root.join("b.dmg");
        std::fs::write(&b, b"b").expect("must write b");
        std::fs::write(&a, b"a").expect("must write a");
        std::fs::write(root.join("c.txt"), b"c").expect("must write c");

        let found = find_first_file_with_extension(&root, "dmg")
            .expect("must scan")
            .expect("must find dmg");
        assert_eq!(found, a);

        std::fs::remove_dir_all(&root).expect("must cleanup");
    }

    #[test]
    fn tauri_build_always_sets_ci_true() {
        let cmd = build_tauri_build_command(
            "aarch64-apple-darwin",
            &[],
            "release",
            "deadbeef",
            "v0.0.0",
            "2026-01-23T00:00:00Z",
            "0.0.0+20260123",
            Some("app,dmg"),
            true,
        );
        let ci = cmd
            .get_envs()
            .find_map(|(key, value)| if key == OsStr::new("CI") { value } else { None });
        assert_eq!(ci, Some(OsStr::new("true")));
    }

    #[test]
    fn resolve_package_target_universal_expands_manifest_keys() {
        let spec = resolve_package_target("darwin-universal").expect("must resolve");
        assert_eq!(spec.platform_key, "darwin-universal");
        assert_eq!(spec.manifest_keys, &["darwin-aarch64", "darwin-x86_64"]);
    }

    #[test]
    fn manifest_merges_multiple_package_envs() {
        let unique = format!(
            "luban-dev-test-manifest-{}-{}",
            std::process::id(),
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .expect("must get time")
                .as_nanos()
        );
        let root = std::env::temp_dir().join(unique);
        std::fs::create_dir_all(&root).expect("must create root dir");

        let darwin = root.join("darwin-universal");
        let windows = root.join("windows-x86_64");
        std::fs::create_dir_all(&darwin).expect("must create darwin dir");
        std::fs::create_dir_all(&windows).expect("must create windows dir");

        std::fs::write(
            darwin.join("package.env"),
            "LUBAN_PACKAGE_VERSION=0.1.6\n\
LUBAN_PACKAGE_URL=https://releases.example/0.1.6/Luban_0.1.6_darwin-universal.app.tar.gz\n\
LUBAN_PACKAGE_SIGNATURE=darwin-signature\n\
LUBAN_PACKAGE_MANIFEST_KEYS=darwin-aarch64,darwin-x86_64\n",
        )
        .expect("must write darwin env");
        std::fs::write(
            windows.join("package.env"),
            "LUBAN_PACKAGE_VERSION=0.1.6\n\
LUBAN_PACKAGE_URL=https://releases.example/0.1.6/Luban_0.1.6_windows-x86_64.msi\n\
LUBAN_PACKAGE_SIGNATURE=windows-signature\n\
LUBAN_PACKAGE_MANIFEST_KEYS=windows-x86_64\n",
        )
        .expect("must write windows env");

        let out = root.join("latest.json");
        run_manifest(root.clone(), out.clone()).expect("must build manifest");
        let raw = std::fs::read_to_string(&out).expect("must read manifest");
        let value: serde_json::Value = serde_json::from_str(&raw).expect("must parse json");
        let platforms = value
            .get("platforms")
            .and_then(|p| p.as_object())
            .expect("must have platforms");
        assert_eq!(platforms.len(), 3);
        assert!(platforms.contains_key("darwin-aarch64"));
        assert!(platforms.contains_key("darwin-x86_64"));
        assert!(platforms.contains_key("windows-x86_64"));

        std::fs::remove_dir_all(&root).expect("must cleanup");
    }
}
