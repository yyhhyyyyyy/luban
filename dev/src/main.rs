use anyhow::{Context as _, Result};
use aws_config::BehaviorVersion;
use aws_credential_types::Credentials;
use aws_sdk_s3::config::Region;
use aws_sdk_s3::primitives::ByteStream;
use clap::{Parser, Subcommand};
use serde::Deserialize;
use std::collections::HashMap;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command as ProcessCommand;
use time::format_description::well_known::Rfc3339;

#[derive(Parser)]
#[command(name = "luban-dev", version, about = "Development helpers for Luban")]
struct Cli {
    #[command(subcommand)]
    cmd: Command,
}

#[derive(Subcommand)]
enum Command {
    /// Package a signed macOS update artifact and generate `latest.json`.
    Package {
        /// `darwin-aarch64`, `darwin-x86_64`, or `darwin-universal`.
        target: String,

        /// `release` or `debug`.
        #[arg(long, default_value = "release")]
        profile: String,

        /// Output directory for packaged artifacts.
        #[arg(long, default_value = ".context/package")]
        out_dir: PathBuf,
    },

    /// Upload packaged artifacts and the update manifest to Cloudflare R2.
    Upload {
        /// Path to the package environment file generated by `just package`.
        #[arg(long, default_value = ".context/package/package.env")]
        package_env: PathBuf,
    },
}

fn env_var(key: &str) -> Result<String> {
    std::env::var(key).with_context(|| format!("missing required env var: {key}"))
}

fn env_var_opt(key: &str) -> Option<String> {
    std::env::var(key).ok()
}

fn read_kv_file(path: &Path) -> Result<HashMap<String, String>> {
    let contents = std::fs::read_to_string(path).with_context(|| format!("read {}", path.display()))?;
    let mut out = HashMap::new();
    for (idx, line) in contents.lines().enumerate() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        let (k, v) = line
            .split_once('=')
            .with_context(|| format!("invalid key=value at {}:{}", path.display(), idx + 1))?;
        out.insert(k.trim().to_owned(), v.trim().to_owned());
    }
    Ok(out)
}

async fn put_object(
    client: &aws_sdk_s3::Client,
    bucket: &str,
    key: &str,
    path: &Path,
    content_type: &str,
    cache_control: &str,
) -> Result<()> {
    let body = ByteStream::from_path(path.to_path_buf())
        .await
        .with_context(|| format!("read upload body {}", path.display()))?;
    client
        .put_object()
        .bucket(bucket)
        .key(key)
        .cache_control(cache_control)
        .content_type(content_type)
        .body(body)
        .send()
        .await
        .with_context(|| format!("upload s3://{bucket}/{key}"))?;
    Ok(())
}

fn file_name(path: &Path) -> Result<String> {
    path.file_name()
        .and_then(|s| s.to_str())
        .map(|s| s.to_owned())
        .with_context(|| format!("invalid file name: {}", path.display()))
}

fn run_cmd(mut cmd: ProcessCommand, context: &str) -> Result<()> {
    let output = cmd.output().with_context(|| format!("spawn {context}"))?;
    if output.status.success() {
        return Ok(());
    }
    anyhow::bail!(
        "{} failed (exit {}):\nstdout:\n{}\nstderr:\n{}",
        context,
        output.status,
        String::from_utf8_lossy(&output.stdout),
        String::from_utf8_lossy(&output.stderr)
    );
}

fn run_cmd_capture_stdout(mut cmd: ProcessCommand, context: &str) -> Result<String> {
    let output = cmd.output().with_context(|| format!("spawn {context}"))?;
    if !output.status.success() {
        anyhow::bail!(
            "{} failed (exit {}):\nstdout:\n{}\nstderr:\n{}",
            context,
            output.status,
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr)
        );
    }
    Ok(String::from_utf8_lossy(&output.stdout).trim().to_owned())
}

#[derive(Deserialize)]
struct CargoMetadata {
    packages: Vec<CargoPackage>,
}

#[derive(Deserialize)]
struct CargoPackage {
    name: String,
    version: String,
}

fn resolve_luban_tauri_version() -> Result<String> {
    let mut cmd = ProcessCommand::new("cargo");
    cmd.arg("metadata").arg("--no-deps").arg("--format-version").arg("1");
    let stdout = run_cmd_capture_stdout(cmd, "cargo metadata")?;
    let meta: CargoMetadata = serde_json::from_str(&stdout).context("parse cargo metadata")?;
    meta.packages
        .into_iter()
        .find(|p| p.name == "luban_tauri")
        .map(|p| p.version)
        .context("luban_tauri not found in cargo metadata")
}

fn now_rfc3339_utc() -> Result<String> {
    let ts = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .context("system clock is before unix epoch")?
        .as_secs();
    let dt = time::OffsetDateTime::from_unix_timestamp(ts as i64).context("invalid timestamp")?;
    Ok(dt.format(&Rfc3339).context("format rfc3339")?)
}

fn find_first_app_dir(bundle_macos: &Path) -> Result<Option<PathBuf>> {
    if !bundle_macos.exists() {
        return Ok(None);
    }
    for entry in std::fs::read_dir(bundle_macos).with_context(|| format!("read_dir {}", bundle_macos.display()))? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() && path.extension().and_then(|s| s.to_str()) == Some("app") {
            return Ok(Some(path));
        }
    }
    Ok(None)
}

fn build_web(profile: &str) -> Result<()> {
    if !ProcessCommand::new("pnpm").arg("--version").output().is_ok() {
        anyhow::bail!("pnpm not found; install pnpm to build the web UI");
    }

    let mut install = ProcessCommand::new("pnpm");
    install.current_dir("web").arg("install");
    run_cmd(install, "pnpm install")?;

    let build_script = if profile == "release" { "build" } else { "build" };
    let mut build = ProcessCommand::new("pnpm");
    build.current_dir("web").arg(build_script);
    run_cmd(build, "pnpm build")?;

    std::fs::create_dir_all("web/out").context("create web/out")?;
    let mut f = std::fs::File::create("web/out/.gitkeep").context("create web/out/.gitkeep")?;
    f.write_all(b"\n").context("write web/out/.gitkeep")?;

    Ok(())
}

fn sign_archive(archive_path: &Path) -> Result<String> {
    let mut help = ProcessCommand::new("cargo");
    help.arg("tauri").arg("--help");
    run_cmd(help, "cargo tauri --help")?;

    let mut sign = ProcessCommand::new("cargo");
    sign.arg("tauri").arg("signer").arg("sign").arg(archive_path);
    let sig = run_cmd_capture_stdout(sign, "cargo tauri signer sign")?;
    Ok(sig)
}

fn package_env_required() -> Result<()> {
    let has_key = std::env::var("TAURI_PRIVATE_KEY").is_ok() || std::env::var("TAURI_PRIVATE_KEY_PATH").is_ok();
    if !has_key {
        anyhow::bail!("missing signing key; set TAURI_PRIVATE_KEY or TAURI_PRIVATE_KEY_PATH (and optional TAURI_PRIVATE_KEY_PASSWORD)");
    }
    Ok(())
}

fn run_package(target: String, profile: String, out_dir: PathBuf) -> Result<()> {
    package_env_required()?;

    let (target_triple, platform_key) = match target.as_str() {
        "darwin-aarch64" => ("aarch64-apple-darwin", "darwin-aarch64"),
        "darwin-x86_64" => ("x86_64-apple-darwin", "darwin-x86_64"),
        "darwin-universal" => ("universal-apple-darwin", "darwin-universal"),
        other => anyhow::bail!(
            "unsupported target: {}; supported targets: darwin-aarch64, darwin-x86_64, darwin-universal",
            other
        ),
    };

    let (build_dir, build_flags) = match profile.as_str() {
        "release" => ("release", Vec::<&str>::new()),
        "debug" | "dev" => ("debug", vec!["--debug"]),
        other => anyhow::bail!("unsupported profile: {}; supported: release, debug", other),
    };

    build_web(&profile)?;

    let mut tauri_build = ProcessCommand::new("cargo");
    tauri_build
        .current_dir("crates/luban_tauri")
        .arg("tauri")
        .arg("build")
        .arg("--ci")
        .arg("--bundles")
        .arg("app")
        .args(build_flags)
        .arg("--target")
        .arg(target_triple);
    run_cmd(tauri_build, "cargo tauri build")?;

    let version = resolve_luban_tauri_version()?;
    let bundle_macos = PathBuf::from(format!("target/{target_triple}/{build_dir}/bundle/macos"));

    let app_dir = find_first_app_dir(&bundle_macos)?
        .with_context(|| format!("macOS bundle not found under: {}", bundle_macos.display()))?;

    std::fs::create_dir_all(&out_dir).with_context(|| format!("create {}", out_dir.display()))?;

    let archive_name = format!("Luban_{version}_{platform_key}.app.tar.gz");
    let archive_path = out_dir.join(&archive_name);

    let mut tar = ProcessCommand::new("tar");
    tar.arg("-C")
        .arg(app_dir.parent().context("missing app parent dir")?)
        .arg("-czf")
        .arg(&archive_path)
        .arg(app_dir.file_name().context("missing app dir name")?);
    run_cmd(tar, "tar app")?;

    let signature = sign_archive(&archive_path)?;
    let sig_path = archive_path.with_extension("app.tar.gz.sig");
    std::fs::write(&sig_path, format!("{signature}\n")).with_context(|| format!("write {}", sig_path.display()))?;

    let base_url = env_var_opt("LUBAN_RELEASE_BASE_URL").unwrap_or_else(|| "https://releases.luban.dev".to_owned());
    let url = format!("{}/{}", base_url.trim_end_matches('/'), archive_name);
    let pub_date = now_rfc3339_utc()?;

    let platforms = if platform_key == "darwin-universal" {
        HashMap::from([
            ("darwin-aarch64".to_owned(), ManifestPlatform { url: url.clone(), signature: signature.clone() }),
            ("darwin-x86_64".to_owned(), ManifestPlatform { url, signature }),
        ])
    } else {
        HashMap::from([(platform_key.to_owned(), ManifestPlatform { url, signature })])
    };

    let manifest = Manifest {
        version: version.clone(),
        notes: "".to_owned(),
        pub_date,
        platforms,
    };

    let manifest_path = out_dir.join("latest.json");
    std::fs::write(&manifest_path, serde_json::to_string_pretty(&manifest)?.to_owned() + "\n")
        .with_context(|| format!("write {}", manifest_path.display()))?;

    let env_path = out_dir.join("package.env");
    let env_contents = format!(
        "LUBAN_PACKAGE_VERSION={}\nLUBAN_PACKAGE_PLATFORM_KEY={}\nLUBAN_PACKAGE_ARCHIVE={}\nLUBAN_PACKAGE_SIGNATURE={}\nLUBAN_PACKAGE_MANIFEST={}\n",
        version,
        platform_key,
        archive_path.display(),
        sig_path.display(),
        manifest_path.display(),
    );
    std::fs::write(&env_path, env_contents).with_context(|| format!("write {}", env_path.display()))?;

    println!("packaged: {}", archive_path.display());
    println!("manifest: {}", manifest_path.display());
    println!("next: just upload");

    Ok(())
}

#[derive(serde::Serialize)]
struct Manifest {
    version: String,
    notes: String,
    pub_date: String,
    platforms: HashMap<String, ManifestPlatform>,
}

#[derive(serde::Serialize)]
struct ManifestPlatform {
    url: String,
    signature: String,
}

async fn run_upload(package_env: PathBuf) -> Result<()> {
    let r2_endpoint_url = env_var("R2_ENDPOINT_URL")?;
    let r2_bucket = env_var("R2_BUCKET")?;
    let access_key = env_var("AWS_ACCESS_KEY_ID")?;
    let secret_key = env_var("AWS_SECRET_ACCESS_KEY")?;
    let session_token = env_var_opt("AWS_SESSION_TOKEN");
    let region = env_var_opt("AWS_DEFAULT_REGION").unwrap_or_else(|| "auto".to_owned());

    let kv = read_kv_file(&package_env)?;
    let archive_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_ARCHIVE")
            .context("LUBAN_PACKAGE_ARCHIVE missing from package.env")?,
    );
    let signature_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_SIGNATURE")
            .context("LUBAN_PACKAGE_SIGNATURE missing from package.env")?,
    );
    let manifest_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_MANIFEST")
            .context("LUBAN_PACKAGE_MANIFEST missing from package.env")?,
    );

    let archive_key = file_name(&archive_path)?;
    let signature_key = format!("{archive_key}.sig");

    let credentials = Credentials::new(access_key, secret_key, session_token, None, "env");

    let shared_config = aws_config::defaults(BehaviorVersion::latest())
        .region(Region::new(region))
        .credentials_provider(credentials)
        .load()
        .await;

    let s3_config = aws_sdk_s3::config::Builder::from(&shared_config)
        .endpoint_url(r2_endpoint_url)
        // Cloudflare R2 endpoints are typically not wildcard-cert'ed for virtual host style.
        // Force path-style addressing to avoid TLS hostname mismatch.
        .force_path_style(true)
        .build();

    let client = aws_sdk_s3::Client::from_conf(s3_config);

    put_object(
        &client,
        &r2_bucket,
        &archive_key,
        &archive_path,
        "application/gzip",
        "public, max-age=31536000, immutable",
    )
    .await?;

    put_object(
        &client,
        &r2_bucket,
        &signature_key,
        &signature_path,
        "text/plain; charset=utf-8",
        "public, max-age=31536000, immutable",
    )
    .await?;

    put_object(
        &client,
        &r2_bucket,
        "latest.json",
        &manifest_path,
        "application/json; charset=utf-8",
        "no-cache",
    )
    .await?;

    let base = env_var_opt("LUBAN_RELEASE_BASE_URL").unwrap_or_else(|| "https://releases.luban.dev".to_owned());
    println!("uploaded: {}/latest.json", base.trim_end_matches('/'));

    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();
    match cli.cmd {
        Command::Package { target, profile, out_dir } => run_package(target, profile, out_dir),
        Command::Upload { package_env } => run_upload(package_env).await,
    }
}
