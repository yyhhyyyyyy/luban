use anyhow::{Context as _, Result};
use clap::{Parser, Subcommand};
use opendal::layers::RetryLayer;
use opendal::services::S3;
use opendal::Operator;
use serde::Deserialize;
use std::collections::HashMap;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command as ProcessCommand;
use std::process::Stdio;
use time::format_description::well_known::Rfc3339;

#[derive(Parser)]
#[command(name = "luban-dev", version, about = "Development helpers for Luban")]
struct Cli {
    #[command(subcommand)]
    cmd: Command,
}

#[derive(Subcommand)]
enum Command {
    /// Package a signed macOS update artifact and generate `latest.json`.
    Package {
        /// `darwin-aarch64`, `darwin-x86_64`, or `darwin-universal`.
        target: String,

        /// `release` or `debug`.
        #[arg(long, default_value = "release")]
        profile: String,

        /// Output directory for packaged artifacts.
        #[arg(long, default_value = ".context/package")]
        out_dir: PathBuf,
    },

    /// Upload packaged artifacts and the update manifest to Cloudflare R2.
    Upload {
        /// Path to the package environment file generated by `just package`.
        #[arg(long, default_value = ".context/package/package.env")]
        package_env: PathBuf,
    },
}

fn env_var(key: &str) -> Result<String> {
    std::env::var(key).with_context(|| format!("missing required env var: {key}"))
}

fn env_var_opt(key: &str) -> Option<String> {
    std::env::var(key).ok()
}

fn read_kv_file(path: &Path) -> Result<HashMap<String, String>> {
    let contents = std::fs::read_to_string(path).with_context(|| format!("read {}", path.display()))?;
    let mut out = HashMap::new();
    for (idx, line) in contents.lines().enumerate() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        let (k, v) = line
            .split_once('=')
            .with_context(|| format!("invalid key=value at {}:{}", path.display(), idx + 1))?;
        let key = k.trim().to_owned();
        let value = expand_kv_value(v.trim(), &out)
            .with_context(|| format!("expand value for {key} at {}:{}", path.display(), idx + 1))?;
        out.insert(key, value);
    }
    Ok(out)
}

fn expand_kv_value(raw: &str, kv: &HashMap<String, String>) -> Result<String> {
    let mut current = raw.to_owned();
    for _ in 0..16 {
        if !current.contains("${") {
            return Ok(current);
        }
        let expanded = expand_kv_value_once(&current, kv)?;
        if expanded == current {
            break;
        }
        current = expanded;
    }
    if current.contains("${") {
        anyhow::bail!("unresolved variable reference: {current}");
    }
    Ok(current)
}

fn expand_kv_value_once(raw: &str, kv: &HashMap<String, String>) -> Result<String> {
    let mut out = String::new();
    let mut i = 0;
    while let Some(pos) = raw[i..].find("${") {
        let abs = i + pos;
        out.push_str(&raw[i..abs]);
        let var_start = abs + 2;
        let Some(end_rel) = raw[var_start..].find('}') else {
            anyhow::bail!("missing closing '}}' for variable reference");
        };
        let var_end = var_start + end_rel;
        let var = raw[var_start..var_end].trim();
        if var.is_empty() {
            anyhow::bail!("empty variable name in reference");
        }

        let replacement = kv
            .get(var)
            .cloned()
            .or_else(|| std::env::var(var).ok())
            .with_context(|| format!("unknown variable: {var}"))?;

        out.push_str(&replacement);
        i = var_end + 1;
    }
    out.push_str(&raw[i..]);
    Ok(out)
}

fn file_name(path: &Path) -> Result<String> {
    path.file_name()
        .and_then(|s| s.to_str())
        .map(|s| s.to_owned())
        .with_context(|| format!("invalid file name: {}", path.display()))
}

fn run_cmd(mut cmd: ProcessCommand, context: &str) -> Result<()> {
    let status = cmd
        .stdin(Stdio::null())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .with_context(|| format!("spawn {context}"))?;
    if status.success() {
        return Ok(());
    }
    anyhow::bail!("{context} failed (exit {status})");
}

fn run_cmd_capture_stdout(mut cmd: ProcessCommand, context: &str) -> Result<String> {
    let output = cmd.output().with_context(|| format!("spawn {context}"))?;
    if !output.status.success() {
        anyhow::bail!(
            "{} failed (exit {}):\nstdout:\n{}\nstderr:\n{}",
            context,
            output.status,
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr)
        );
    }
    Ok(String::from_utf8_lossy(&output.stdout).trim().to_owned())
}

#[derive(Deserialize)]
struct CargoMetadata {
    packages: Vec<CargoPackage>,
}

#[derive(Deserialize)]
struct CargoPackage {
    name: String,
    version: String,
}

fn resolve_luban_tauri_version() -> Result<String> {
    let mut cmd = ProcessCommand::new("cargo");
    cmd.arg("metadata").arg("--no-deps").arg("--format-version").arg("1");
    let stdout = run_cmd_capture_stdout(cmd, "cargo metadata")?;
    let meta: CargoMetadata = serde_json::from_str(&stdout).context("parse cargo metadata")?;
    meta.packages
        .into_iter()
        .find(|p| p.name == "luban_tauri")
        .map(|p| p.version)
        .context("luban_tauri not found in cargo metadata")
}

fn now_rfc3339_utc() -> Result<String> {
    let ts = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .context("system clock is before unix epoch")?
        .as_secs();
    let dt = time::OffsetDateTime::from_unix_timestamp(ts as i64).context("invalid timestamp")?;
    Ok(dt.format(&Rfc3339).context("format rfc3339")?)
}

fn find_first_app_dir(bundle_macos: &Path) -> Result<Option<PathBuf>> {
    if !bundle_macos.exists() {
        return Ok(None);
    }
    for entry in std::fs::read_dir(bundle_macos).with_context(|| format!("read_dir {}", bundle_macos.display()))? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() && path.extension().and_then(|s| s.to_str()) == Some("app") {
            return Ok(Some(path));
        }
    }
    Ok(None)
}

fn build_web(profile: &str) -> Result<()> {
    if !ProcessCommand::new("pnpm").arg("--version").output().is_ok() {
        anyhow::bail!("pnpm not found; install pnpm to build the web UI");
    }

    let mut install = ProcessCommand::new("pnpm");
    install.current_dir("web").arg("install");
    run_cmd(install, "pnpm install")?;

    let build_script = if profile == "release" { "build" } else { "build" };
    let mut build = ProcessCommand::new("pnpm");
    build.current_dir("web").arg(build_script);
    run_cmd(build, "pnpm build")?;

    std::fs::create_dir_all("web/out").context("create web/out")?;
    let mut f = std::fs::File::create("web/out/.gitkeep").context("create web/out/.gitkeep")?;
    f.write_all(b"\n").context("write web/out/.gitkeep")?;

    Ok(())
}

fn sign_archive(archive_path: &Path) -> Result<String> {
    let mut help = ProcessCommand::new("cargo");
    help.arg("tauri").arg("--help");
    run_cmd(help, "cargo tauri --help")?;

    // `cargo tauri signer sign` writes a `.sig` file next to the input file.
    // Use the file as the source of truth instead of parsing stdout.
    let mut sign = ProcessCommand::new("cargo");
    sign.arg("tauri").arg("signer").arg("sign").arg(archive_path);
    run_cmd(sign, "cargo tauri signer sign")?;

    let mut extension = archive_path
        .extension()
        .context("archive has no extension")?
        .to_os_string();
    extension.push(".sig");
    let sig_path = archive_path.with_extension(extension);

    let signature = std::fs::read_to_string(&sig_path)
        .with_context(|| format!("read signature {}", sig_path.display()))?
        .trim()
        .to_owned();
    if signature.is_empty() {
        anyhow::bail!("signature file is empty: {}", sig_path.display());
    }
    Ok(signature)
}

fn package_env_required() -> Result<()> {
    let has_key = std::env::var("TAURI_PRIVATE_KEY").is_ok()
        || std::env::var("TAURI_PRIVATE_KEY_PATH").is_ok()
        || std::env::var("TAURI_SIGNING_PRIVATE_KEY").is_ok();
    if !has_key {
        anyhow::bail!(
            "missing signing key; set TAURI_PRIVATE_KEY/TAURI_PRIVATE_KEY_PATH or TAURI_SIGNING_PRIVATE_KEY"
        );
    }
    Ok(())
}

fn apply_updater_signing_env(cmd: &mut ProcessCommand) {
    if env_var_opt("TAURI_SIGNING_PRIVATE_KEY").is_none() {
        if let Some(value) = env_var_opt("TAURI_PRIVATE_KEY") {
            cmd.env("TAURI_SIGNING_PRIVATE_KEY", value);
        } else if let Some(value) = env_var_opt("TAURI_PRIVATE_KEY_PATH") {
            cmd.env("TAURI_SIGNING_PRIVATE_KEY", value);
        }
    }

    if env_var_opt("TAURI_SIGNING_PRIVATE_KEY_PASSWORD").is_none() {
        if let Some(value) = env_var_opt("TAURI_PRIVATE_KEY_PASSWORD") {
            cmd.env("TAURI_SIGNING_PRIVATE_KEY_PASSWORD", value);
        }
    }
}

fn run_package(target: String, profile: String, out_dir: PathBuf) -> Result<()> {
    package_env_required()?;

    let (target_triple, platform_key) = match target.as_str() {
        "darwin-aarch64" => ("aarch64-apple-darwin", "darwin-aarch64"),
        "darwin-x86_64" => ("x86_64-apple-darwin", "darwin-x86_64"),
        "darwin-universal" => ("universal-apple-darwin", "darwin-universal"),
        other => anyhow::bail!(
            "unsupported target: {}; supported targets: darwin-aarch64, darwin-x86_64, darwin-universal",
            other
        ),
    };

    let (build_dir, build_flags) = match profile.as_str() {
        "release" => ("release", Vec::<&str>::new()),
        "debug" | "dev" => ("debug", vec!["--debug"]),
        other => anyhow::bail!("unsupported profile: {}; supported: release, debug", other),
    };

    build_web(&profile)?;

    let mut tauri_build = ProcessCommand::new("cargo");
    tauri_build
        .current_dir("crates/luban_tauri")
        .arg("tauri")
        .arg("build")
        .arg("--ci")
        // TODO: Skip stapling until the app passes notarization.
        .arg("--skip-stapling")
        .arg("--bundles")
        .arg("app")
        .args(build_flags)
        .arg("--target")
        .arg(target_triple);
    apply_updater_signing_env(&mut tauri_build);
    run_cmd(tauri_build, "cargo tauri build")?;

    let version = resolve_luban_tauri_version()?;
    let bundle_macos = PathBuf::from(format!("target/{target_triple}/{build_dir}/bundle/macos"));

    let app_dir = find_first_app_dir(&bundle_macos)?
        .with_context(|| format!("macOS bundle not found under: {}", bundle_macos.display()))?;

    std::fs::create_dir_all(&out_dir).with_context(|| format!("create {}", out_dir.display()))?;

    let archive_name = format!("Luban_{version}_{platform_key}.app.tar.gz");
    let archive_path = out_dir.join(&archive_name);

    let mut tar = ProcessCommand::new("tar");
    tar.arg("-C")
        .arg(app_dir.parent().context("missing app parent dir")?)
        .arg("-czf")
        .arg(&archive_path)
        .arg(app_dir.file_name().context("missing app dir name")?);
    run_cmd(tar, "tar app")?;

    let signature = sign_archive(&archive_path)?;

    let mut sig_ext = archive_path
        .extension()
        .context("archive has no extension")?
        .to_os_string();
    sig_ext.push(".sig");
    let sig_path = archive_path.with_extension(sig_ext);

    let base_url = env_var_opt("LUBAN_RELEASE_BASE_URL").unwrap_or_else(|| "https://releases.luban.dev".to_owned());
    let url = format!("{}/{}/{}", base_url.trim_end_matches('/'), version, archive_name);
    let pub_date = now_rfc3339_utc()?;

    let platforms = if platform_key == "darwin-universal" {
        HashMap::from([
            ("darwin-aarch64".to_owned(), ManifestPlatform { url: url.clone(), signature: signature.clone() }),
            ("darwin-x86_64".to_owned(), ManifestPlatform { url, signature }),
        ])
    } else {
        HashMap::from([(platform_key.to_owned(), ManifestPlatform { url, signature })])
    };

    let manifest = Manifest {
        version: version.clone(),
        notes: "".to_owned(),
        pub_date,
        platforms,
    };

    let manifest_path = out_dir.join("latest.json");
    std::fs::write(&manifest_path, serde_json::to_string_pretty(&manifest)?.to_owned() + "\n")
        .with_context(|| format!("write {}", manifest_path.display()))?;

    let env_path = out_dir.join("package.env");
    let env_contents = format!(
        "LUBAN_PACKAGE_VERSION={}\nLUBAN_PACKAGE_PLATFORM_KEY={}\nLUBAN_PACKAGE_ARCHIVE={}\nLUBAN_PACKAGE_SIGNATURE={}\nLUBAN_PACKAGE_MANIFEST={}\n",
        version,
        platform_key,
        archive_path.display(),
        sig_path.display(),
        manifest_path.display(),
    );
    std::fs::write(&env_path, env_contents).with_context(|| format!("write {}", env_path.display()))?;

    println!("packaged: {}", archive_path.display());
    println!("manifest: {}", manifest_path.display());
    println!("next: just upload");

    Ok(())
}

#[derive(serde::Serialize)]
struct Manifest {
    version: String,
    notes: String,
    pub_date: String,
    platforms: HashMap<String, ManifestPlatform>,
}

#[derive(serde::Serialize)]
struct ManifestPlatform {
    url: String,
    signature: String,
}

fn build_r2_operator(
    endpoint_url: &str,
    bucket: &str,
    region: &str,
    access_key_id: &str,
    secret_access_key: &str,
    session_token: Option<&str>,
) -> Result<Operator> {
    let mut builder = S3::default()
        .endpoint(endpoint_url)
        .bucket(bucket)
        .region(region)
        .access_key_id(access_key_id)
        .secret_access_key(secret_access_key);

    if let Some(token) = session_token {
        if !token.trim().is_empty() {
            builder = builder.session_token(token);
        }
    }

    // Avoid metadata calls that don't apply to local packaging workflows.
    let builder = builder.disable_ec2_metadata().disable_stat_with_override();

    Ok(Operator::new(builder)
        .context("build opendal S3 operator")?
        .layer(RetryLayer::new())
        .finish())
}

async fn upload_file(
    op: &Operator,
    bucket: &str,
    key: &str,
    path: &Path,
    content_type: &str,
    cache_control: &str,
) -> Result<()> {
    let body = tokio::fs::read(path)
        .await
        .with_context(|| format!("read upload body {}", path.display()))?;
    op.write_with(key, body)
        .content_type(content_type)
        .cache_control(cache_control)
        .await
        .with_context(|| format!("upload s3://{bucket}/{key}"))?;
    Ok(())
}

async fn run_upload(package_env: PathBuf) -> Result<()> {
    let r2_endpoint_url = env_var("R2_ENDPOINT_URL")?;
    let r2_bucket = env_var("R2_BUCKET")?;
    let access_key = env_var("AWS_ACCESS_KEY_ID")?;
    let secret_key = env_var("AWS_SECRET_ACCESS_KEY")?;
    let session_token = env_var_opt("AWS_SESSION_TOKEN");
    let region = env_var_opt("AWS_DEFAULT_REGION").unwrap_or_else(|| "auto".to_owned());

    let kv = read_kv_file(&package_env)?;
    let version = kv
        .get("LUBAN_PACKAGE_VERSION")
        .context("LUBAN_PACKAGE_VERSION missing from package.env")?
        .trim()
        .to_owned();
    let archive_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_ARCHIVE")
            .context("LUBAN_PACKAGE_ARCHIVE missing from package.env")?,
    );
    let signature_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_SIGNATURE")
            .context("LUBAN_PACKAGE_SIGNATURE missing from package.env")?,
    );
    let manifest_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_MANIFEST")
            .context("LUBAN_PACKAGE_MANIFEST missing from package.env")?,
    );

    let archive_name = file_name(&archive_path)?;
    let archive_key = format!("{version}/{archive_name}");
    let signature_key = format!("{archive_key}.sig");

    let op = build_r2_operator(
        &r2_endpoint_url,
        &r2_bucket,
        &region,
        &access_key,
        &secret_key,
        session_token.as_deref(),
    )?;

    upload_file(
        &op,
        &r2_bucket,
        &archive_key,
        &archive_path,
        "application/gzip",
        "public, max-age=31536000, immutable",
    )
    .await?;

    upload_file(
        &op,
        &r2_bucket,
        &signature_key,
        &signature_path,
        "text/plain; charset=utf-8",
        "public, max-age=31536000, immutable",
    )
    .await?;

    upload_file(
        &op,
        &r2_bucket,
        "latest.json",
        &manifest_path,
        "application/json; charset=utf-8",
        "no-cache",
    )
    .await?;

    let base = env_var_opt("LUBAN_RELEASE_BASE_URL").unwrap_or_else(|| "https://releases.luban.dev".to_owned());
    println!("uploaded: {}/latest.json", base.trim_end_matches('/'));

    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();
    match cli.cmd {
        Command::Package { target, profile, out_dir } => run_package(target, profile, out_dir),
        Command::Upload { package_env } => run_upload(package_env).await,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn expand_kv_value_uses_prior_kv_entries() {
        let kv = HashMap::from([("FOO".to_owned(), "bar".to_owned())]);
        let expanded = expand_kv_value("prefix-${FOO}-suffix", &kv).expect("must expand");
        assert_eq!(expanded, "prefix-bar-suffix");
    }

    #[test]
    fn expand_kv_value_uses_process_env() {
        let kv = HashMap::new();
        let prev = std::env::var_os("LUBAN_TEST_ENV");
        unsafe {
            std::env::set_var("LUBAN_TEST_ENV", "value");
        }
        let expanded = expand_kv_value("${LUBAN_TEST_ENV}", &kv).expect("must expand");
        assert_eq!(expanded, "value");
        if let Some(v) = prev {
            unsafe {
                std::env::set_var("LUBAN_TEST_ENV", v);
            }
        } else {
            unsafe {
                std::env::remove_var("LUBAN_TEST_ENV");
            }
        }
    }

    #[test]
    fn expand_kv_value_errors_on_unknown_variable() {
        let kv = HashMap::new();
        let err = expand_kv_value("${LUBAN_TEST_ENV_MISSING}", &kv)
            .expect_err("must error on missing variable");
        assert!(format!("{err:#}").contains("unknown variable"));
    }
}
